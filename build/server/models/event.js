// Generated by CoffeeScript 1.10.0
var Event, RRule, cozydb, iCalDurationToUnitValue, moment;

cozydb = require('cozydb');

moment = require('moment-timezone');

RRule = require('rrule').RRule;

module.exports = Event = cozydb.getModel('Event', {
  start: {
    type: String
  },
  end: {
    type: String
  },
  place: {
    type: String
  },
  details: {
    type: String
  },
  description: {
    type: String
  },
  rrule: {
    type: String
  },
  tags: {
    type: function(x) {
      return x;
    }
  },
  attendees: {
    type: [cozydb.NoSchema]
  },
  related: {
    type: String,
    "default": null
  },
  timezone: {
    type: String
  },
  alarms: {
    type: [cozydb.NoSchema]
  }
});

Event.dateFormat = 'YYYY-MM-DD';

Event.ambiguousDTFormat = 'YYYY-MM-DDTHH:mm:00.000';

Event.utcDTFormat = 'YYYY-MM-DDTHH:mm:00.000Z';

Event.alarmTriggRegex = /(\+?|-)PT?(\d+)(W|D|H|M|S)/;

Event.all = function(params, callback) {
  return Event.request("all", params, callback);
};

Event.prototype.isRecurring = function() {
  return (this.rrule != null) && this.rrule.length > 0;
};

Event.prototype.isAllDay = function() {
  return this.start.length === 10;
};

iCalDurationToUnitValue = function(s) {
  var m, o;
  m = s.match(/(\d+)(W|D|H|M|S)/);
  o = {};
  o[m[2].toLowerCase()] = parseInt(m[1]);
  return o;
};

Event.prototype._getRecurringStartDates = function(startingBound, endingBound) {
  var fixDSTTroubles, options, rrule, startDates, startJsDate, startMDate, starts;
  starts = [];
  if (!this.isRecurring()) {
    return starts;
  }
  startMDate = moment.tz(this.start, this.timezone);
  startJsDate = new Date(startMDate.toISOString());
  options = RRule.parseString(this.rrule);
  options.dtstart = startJsDate;
  rrule = new RRule(options);
  fixDSTTroubles = (function(_this) {
    return function(rruleStartJsDate) {
      var diff, startRealMDate;
      startRealMDate = moment.tz(rruleStartJsDate.toISOString(), _this.timezone);
      diff = startMDate.hour() - startRealMDate.hour();
      if (diff === 23) {
        diff = -1;
      } else if (diff === -23) {
        diff = 1;
      }
      startRealMDate.add(diff, 'hours');
      return startRealMDate;
    };
  })(this);
  startDates = rrule.between(startingBound.toDate(), endingBound.toDate()).map(fixDSTTroubles);
  return startDates;
};

Event.prototype.getAlarms = function(userTimezone) {
  var alarm, alarms, cozyAlarm, duration, endDate, event, i, in24h, index, j, key, len, len1, now, ref, startDate, startDates, trigg, unitValues, value;
  alarms = [];
  ref = this.alarms;
  for (index = i = 0, len = ref.length; i < len; index = ++i) {
    alarm = ref[index];
    startDates = [];
    if (this.isRecurring()) {
      now = moment().tz(userTimezone);
      in24h = moment(now).add(1, 'days');
      startDates = this._getRecurringStartDates(now, in24h);
    } else {
      startDates = [moment.tz(this.start, 'UTC')];
    }
    for (j = 0, len1 = startDates.length; j < len1; j++) {
      startDate = startDates[j];
      startDate.tz(userTimezone);
      trigg = startDate.clone();
      unitValues = iCalDurationToUnitValue(alarm.trigg);
      for (key in unitValues) {
        value = unitValues[key];
        trigg.subtract(value, key);
      }
      cozyAlarm = {
        _id: this._id + "_" + index,
        action: alarm.action,
        trigg: trigg.toISOString(),
        description: this.description,
        timezone: this.timezone
      };
      duration = moment(this.end).diff(moment(this.start), 'seconds');
      endDate = startDate.clone().add(duration, 'seconds');
      event = {
        start: startDate,
        end: endDate,
        place: this.place,
        details: this.details,
        description: this.description,
        tags: this.tags
      };
      cozyAlarm.event = event;
      alarms.push(cozyAlarm);
    }
  }
  return alarms;
};
